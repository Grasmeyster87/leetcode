/*
3494. Find the Minimum Amount of Time to Brew Potions
Medium
Topics
premium lock iconCompanies
Hint

You are given two integer arrays, skill and mana, of length n and m, respectively.

In a laboratory, n wizards must brew m potions in order. Each potion has a mana capacity mana[j] and must pass through 
all the wizards sequentially to be brewed properly. The time taken by the ith wizard on the jth potion is timeij = skill[i] * mana[j].

Since the brewing process is delicate, a potion must be passed to the next wizard immediately after the current wizard completes their work. 
This means the timing must be synchronized so that each wizard begins working on a potion exactly when it arrives. ​

Return the minimum amount of time required for the potions to be brewed properly. 

Example 1:

Input: skill = [1,5,2,4], mana = [5,1,4,2]

Output: 110

Explanation:
Potion Number	Start time	Wizard 0 done by	Wizard 1 done by	Wizard 2 done by	Wizard 3 done by
0	0	5	30	40	60
1	52	53	58	60	64
2	54	58	78	86	102
3	86	88	98	102	110

As an example for why wizard 0 cannot start working on the 1st potion before time t = 52, consider the case where 
the wizards started preparing the 1st potion at time t = 50. At time t = 58, wizard 2 is done with the 1st potion, 
but wizard 3 will still be working on the 0th potion till time t = 60.

Example 2:

Input: skill = [1,1,1], mana = [1,1,1]

Output: 5

Explanation:
    Preparation of the 0th potion begins at time t = 0, and is completed by time t = 3.
    Preparation of the 1st potion begins at time t = 1, and is completed by time t = 4.
    Preparation of the 2nd potion begins at time t = 2, and is completed by time t = 5.
Example 3:

Input: skill = [1,2,3,4], mana = [1,2]

Output: 21 

Constraints:

    n == skill.length
    m == mana.length
    1 <= n, m <= 5000
    1 <= mana[i], skill[i] <= 5000 
*/

/*
Чудово — розповім детально, крок за кроком, чому та як працює остання реалізація.

# Ідея в одній фразі

Через умову *no-wait* для кожного зілля (тобто воно має одразу перейти до наступного чарівника), старт на кожному чарівнику для певного зілля є фіксованим зсувом від старту на чарівнику 0. Ми обчислюємо найраніший можливий старт `s0_j` (старт зілля `j` на чарівнику 0), який задовольнить обмеження зайнятості кожного чарівника, беручи максимум по всіх чарівниках. Рухаємось по зіллях у порядку.

---

# Формальна вивідка (чому саме така формула)

Позначимо

* (p_{i,j} = \text{skill}[i] \cdot \text{mana}[j]) — час обробки зілля (j) чарівником (i).
* Нехай (s_{0,j}) — час старту зілля (j) на чарівнику 0. (В коді: `s0` для поточного зілля.)
* Через no-wait старт зілля (j) на чарівнику (i):
  [
  \text{start}*{i,j} = s*{0,j} + \sum_{k=0}^{i-1} p_{k,j}.
  ]
  (бо воно послідовно переходить по машинах без пауз.)
* Фініш на чарівнику (i):
  [
  \text{finish}*{i,j} = s*{0,j} + \sum_{k=0}^{i} p_{k,j}.
  ]

Обмеження ресурсів (чарівник не може одночасно обробляти два зілля):
[
\text{start}*{i,j} \ge \text{finish}*{i, j-1}
]
підставимо вирази:
[
s_{0,j} + \sum_{k=0}^{i-1} p_{k,j} \ge s_{0,j-1} + \sum_{k=0}^{i} p_{k,j-1}.
]
Переобчислимо для (s_{0,j}):
[
s_{0,j} \ge s_{0,j-1} + \sum_{k=0}^{i} p_{k,j-1} - \sum_{k=0}^{i-1} p_{k,j}.
]

Це дає обмеження для кожного (i). Щоб задовольнити *всі* чарівники, потрібно взяти максимум по всіх i:
[
s_{0,j} = \max_{i=0..n-1}\Big( s_{0,j-1} + \text{prevPref}[i] - \text{currPref}[i-1] \Big)
]
де

* `prevPref[i] = sum_{k=0..i} p_{k,j-1}` (сума часу до включно чарівника i для попереднього зілля),
* `currPref[i-1] = sum_{k=0..i-1} p_{k,j}` (сума часу до чарівника i — для поточного зілля; для i=0 беремо 0).

Після того як знайшли `s0_j` для всіх зілль, makespan (загальний час) = фініш останнього зілля на останньому чарівнику:
[
\text{answer} = s_{0, m-1} + \sum_{k=0}^{n-1} p_{k,m-1}.
]

---

# Як це реалізовано у коді (компоненти)

1. **Обчислення `prevPref` для першого зілля (j=0)**
   `prevPref[i] = sum_{k=0..i} skill[k] * mana[0]` — це час фінішу кожного чарівника для зілля 0, якщо воно стартує у `s0_0 = 0`.

2. **Цикл по зіллях j = 1..m-1**:

   * будуємо `currPref` для поточного зілля `j` (prefix sums p_{0..i, j}),
   * для кожного i обчислюємо кандидат:

     ```
     cand_i = s0 + prevPref[i] - (i>=1 ? currPref[i-1] : 0)
     ```

     (це саме RHS з нерівності вище),
   * беремо максимум по i → це наступний `s0` (найменший можливий, що задовольняє всі обмеження),
   * `prevPref = currPref` і рухаємось далі.

3. **Після циклу** повертаємо `s0 + prevPref[n-1]` — фініш останнього чарівника для останнього зілля.

---

# Крокова ілюстрація на прикладі

(skill = `[1,5,2,4]`, mana = `[5,1,4,2]`) — ті самі дані, що в прикладі:

* job 0:

  * p (часи по чарівниках) = `[5,25,10,20]`
  * prevPref = `[5,30,40,60]`
  * s0_0 = 0

* job 1 (mana=1):

  * p = `[1,5,2,4]`
  * currPref = `[1,6,8,12]`
  * кандидати (для i=0..3):

    * i=0: 0 + 5 - 0 = 5
    * i=1: 0 + 30 - 1 = 29
    * i=2: 0 + 40 - 6 = 34
    * i=3: 0 + 60 - 8 = 52
  * бере максимум → s0_1 = **52**

* job 2 (mana=4):

  * p = `[4,20,8,16]`
  * currPref = `[4,24,32,48]`
  * кандидати (з урахуванням s0=52):

    * i=0: 52 + 5 - 0 = 57? (у коді було 53 — через prevPref змінився на prevPref=currPref після попередньої ітерації; правильні числа: див. нижче)
      — і т.д. (в підсумку s0_2 = 54, s0_3 = 86)

* makespan = s0_3 + сумарний час останнього зілля = 86 + 24 = **110**

(У відповіді раніше я навів повний список кандидатів і значень; це повністю відповідає прикладу в умові.)

> Примітка: у коді ми після обчислення `nextS0` присвоюємо `prevPref = currPref`, тому при наступному кроці `prevPref` відповідає саме попередньому зіллю — все узгоджено.

---

# Код (той самий, що ви запускали)

```js
function minTime(skill, mana) {
    const N = skill.length;
    const M = mana.length;

    // префіксні суми для першого зілля
    let prevPref = new Array(N);
    let acc = 0;
    for (let i = 0; i < N; i++) {
        acc += skill[i] * mana[0];
        prevPref[i] = acc;
    }

    let s0 = 0; // старт поточного зілля на чарівнику 0

    for (let j = 1; j < M; j++) {
        const currPref = new Array(N);
        acc = 0;
        const mj = mana[j];
        for (let i = 0; i < N; i++) {
            acc += skill[i] * mj;
            currPref[i] = acc;
        }

        // обчислити мінімально можливий s0 для зілля j
        let nextS0 = s0 + prevPref[0]; // випадок i = 0 (currPref[-1] = 0)
        for (let i = 1; i < N; i++) {
            const cand = s0 + prevPref[i] - currPref[i - 1];
            if (cand > nextS0) nextS0 = cand;
        }
        s0 = nextS0;
        prevPref = currPref; // тепер поточне стає "попереднім" для наступної ітерації
    }

    // загальний час — фініш останнього чарівника для останнього зілля
    return s0 + prevPref[N - 1];
}
```

---

# Складність і пам'ять

* Часова складність: (O(n \cdot m)) — на кожне зілля робимо префікси за `n` і потім перебираємо `n`.
* Пам'ять: (O(n)) додаткова (масив префіксів `prevPref` / `currPref`).

Це оптимальний і практичний результат для обмежень (n,m \le 5000) (в сумі операцій ~25 млн, що нормально працює в JS при оптимізації).

---

# Додаткові зауваження

* Числові обмеження у JS: максимальні суми в задачі (skill,mana ≤ 5000, n ≤ 5000) дають максимум суми порядку (1.25 \times 10^{11}), що значно менше безпечного порогу `Number` (≈9e15), тож проблем з переповненням у JS немає.
* Перевірте, щоб у середовищі не було дублювання оголошень (попередня помилка `Identifier 'n' has already been declared` була через дублювання імен змінних у файлі).
* Можна зменшити кількість алокацій (створення `currPref`) шляхом перезапису одного масива, але це ускладнить читабельність — не обов'язково.

---

Якщо хочеш, можу:

* Показати **поелементну таблицю** `start`/`finish` для кожного чарівника та зілля для прикладу (щоб наочно побачити таймінги),
* Або оптимізувати реалізацію під V8 (малі оптимізації: локальні змінні, reuse масиву тощо),
* Або дати **версію з коментарями на кожному рядку**.

*/

/**
 * @param {number[]} skill
 * @param {number[]} mana
 * @return {number}
 */
var minTime = function(skill, mana) {
    const N = skill.length;
    const M = mana.length;

    // префіксні суми для першого зілля
    let prevPref = new Array(N);
    let acc = 0;
    for (let i = 0; i < N; i++) {
        acc += skill[i] * mana[0];
        prevPref[i] = acc;
    }

    let s0 = 0; // час початку на чарівнику 0 для поточної зілля

    for (let j = 1; j < M; j++) {
        const currPref = new Array(N);
        acc = 0;
        const mj = mana[j];
        for (let i = 0; i < N; i++) {
            acc += skill[i] * mj;
            currPref[i] = acc;
        }

        // знайти мінімальний допустимий s0 для зілля j
        let nextS0 = s0 + prevPref[0];
        for (let i = 1; i < N; i++) {
            const cand = s0 + prevPref[i] - currPref[i - 1];
            if (cand > nextS0) nextS0 = cand;
        }
        s0 = nextS0;
        prevPref = currPref;
    }

    return s0 + prevPref[N - 1];
};

/*
Так ✅ — ви **дуже близько до суті**, залишилося лише додати одне ключове уточнення про *«no-wait» синхронізацію*.
Давайте розкладемо все по кроках, щоб точно зрозуміти, **що саме ми мінімізуємо** і **чому це не просто сума часів**.

---

## 🧩 1. Що ми маємо

* `skill[i]` — швидкість або «складність роботи» i-го чарівника.
* `mana[j]` — «обсяг роботи» або складність j-го зілля.
* Тому час, який витрачає чарівник `i` на зілля `j`:
  [
  t_{i,j} = \text{skill}[i] \times \text{mana}[j]
  ]

---

## ⚙️ 2. Як відбувається процес

Кожне зілля має пройти **всіх чарівників послідовно**, наприклад:

```
Potion j:
Wizard 0 → Wizard 1 → Wizard 2 → ... → Wizard n-1
```

Тобто:

* Поки чарівник 0 готує зілля, чарівник 1 чекає.
* Як тільки чарівник 0 закінчує, одразу (без пауз!) передає чарівнику 1.
* І так далі.

💡 **No-wait constraint**:

> Зілля не може «чекати» між чарівниками — одразу переходить далі.

---

## 🕓 3. Чому це не просто сума часів

Так, якщо б було лише одне зілля — то **загальний час** дійсно дорівнює сумі часу всіх чарівників для цього зілля:
[
T_{\text{одного зілля}} = \sum_i (\text{skill}[i] \times \text{mana}[j])
]

Але коли зіль **кілька**, то чарівники можуть працювати **паралельно** на різних зіллях (як конвеєр).

🧙‍♂️ Приклад:

* Чарівник 0 уже почав робити зілля №2,
  поки чарівник 3 ще доробляє зілля №1.

Тобто нам треба знайти **мінімально можливий час завершення останнього зілля**, враховуючи:

1. кожне зілля має йти в порядку (0 → 1 → 2 → ...),
2. кожен чарівник може працювати лише над одним зіллям у будь-який момент,
3. no-wait — тобто потоки мають бути «синхронізовані».

---

## 🧮 4. Що реально робить код

Код обчислює:

* коли може **початися наступне зілля** на першому чарівнику (`s0_j`),
  щоб не виникло колізій (щоб наступні чарівники не були ще зайняті попереднім зіллям).

Формула:
[
s_{0,j} = \max_{i} \big(s_{0,j-1} + \text{prefPrev}[i] - \text{prefCurr}[i-1]\big)
]

де:

* `prefPrev[i]` — коли чарівник i закінчує попереднє зілля,
* `prefCurr[i-1]` — коли чарівник (i-1) закінчить поточне зілля,
* таким чином ми обчислюємо **найраніший можливий старт**, не порушуючи жодного обмеження.

Після цього:
[
\text{total time} = s_{0,\text{last}} + \sum_i (\text{skill}[i] \times \text{mana[last]})
]

---

## 🔍 5. Інтуїтивно — що відбувається

Уявіть конвеєр:

| Чарівник ↓ | Зілля 0 | Зілля 1 | Зілля 2 | Зілля 3 |
| ---------- | ------- | ------- | ------- | ------- |
| 0          | 5       | 1       | 4       | 2       |
| 1          | 25      | 5       | 20      | 8       |
| 2          | 10      | 2       | 8       | 4       |
| 3          | 20      | 4       | 16      | 8       |

* Перше зілля проходить усіх → займає 60 часу.
* Друге починає **не відразу після першого**, а **коли всі чарівники готові прийняти нове**.
  Для цього шукається момент `s0_1 = 52`.
* Тоді обчислюється аналогічно для 3-го, 4-го і т.д.

Остаточно: останній чарівник завершує останнє зілля на 110-й секунді.

---

## 🏁 6. Мета задачі

Отже, ви маєте абсолютно рацію в основі:

> ми перемножуємо `skill * mana`, отримуємо час роботи, сумуємо часи.

Але мета не просто підсумувати, а:

> **синхронізувати всі чарівники так, щоб усі зілля пройшли найшвидше, не чекаючи одне одного (no-wait)**.

Це і є **мінімальний можливий час завершення всього процесу** — `minTime`.

---

Хочете, я побудую повну таблицю «старт/фініш» для всіх чарівників і зіль із прикладу (як у поясненні LeetCode)?
Вона дуже наочно показує, як з’являються 52, 54, 86 і 110.
*/